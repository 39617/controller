<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>Controller: E:/ISEL Projects/controller/contiki_multiple_interface/tools/sensniff/README.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Controller
   </div>
   <div id="projectbrief">IOT Project</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">E:/ISEL Projects/controller/contiki_multiple_interface/tools/sensniff/README.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="tools_2sensniff_2README_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;sensniff</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;========</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;*Live Traffic Capture and Sniffer for IEEE 802.15.4 networks.*</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;This tool helps you perform live traffic capture and analysis for IEEE 802.15.4 networks. sensniff has two components:</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160; * **Peripheral**: This is an embedded device with a .15.4 trasceiver which captures all network frames and streams them over to the host.</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160; * **Host**: This is a python script which runs on a PC. It reads network packets captured by the peripheral, converts them to PCAP and pipes them to [wireshark](http://www.wireshark.org/).</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;Other than network packet capture, the host can send commands to the peripheral to achieve secondary functionality e.g. change radio channel.</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;sensniff is distributed under the terms of the 3-clause BSD license. See [LICENSE](https://github.com/g-oikonomou/sensniff/blob/master/LICENSE).</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;sensniff has been developed and tested on Ubuntu and Mac OS X. sensniff does not work on Windows (and most likely never will).</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;How to Use</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;==========</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;In a nutshell, three steps are involved:</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160; * Program your peripheral with a sensniff-compliant firmware and connect it to your PC</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160; * Run the host tool (resides in `host/`)</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160; * Run wireshark, start a capture and enjoy</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;Program your Peripheral</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;-----------------------</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;First, you need to have a device with a .15.4 transceiver and you need to program the device with a sniffer firmware. Here, we have the following options:</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160; * [Contiki OS](http://www.contiki-os.org) firmware</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160; * sensniff firmware</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;### Sensniff with Contiki</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;Contiki currently provides a sensniff example that supports a very wide variety of hardware platforms, including but not limited to:</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160; * Texas Instruments CC2538 devices. This will work with a CC2538 EM in CDC-ACM mode, as well as with Srf06EB+CC2538EM over UART.</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160; * Texas Instruments CC2530 devices. This will work with CC2531 USB dongles as well as CC2530 Evaluation Modules on a SmartRF 05 Evaluation Board.</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160; * Zolertia Zoul, in 2.4GHz as well as in sub-ghz mode.</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160; * Texas Instruments CC13xx/CC26xx platforms, such as Launchpads and Srf06+CC13xx/CC26xx EMs</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;### Sensniff Firmware</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;In the future, sensniff will also provide sources for a series of wireless sensor platforms. The first platforms to be supported will be the same as those with examples in the Contiki source tree (see above). These will be distributed through a separate repo.</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;Run the Host Tool</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;-----------------</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;The host-side tool assumes that the peripheral appears as a serial port on the host PC. If your embedded device has a native USB interface, it will have to enumerate as a CDC-ACM device (e.g. the CC2531 USB dongle running the Contiki sniffer example).</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;The best way to start:</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;`python sensniff.py -h`</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;Some examples:</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160; * To read captures from `/dev/ttyUSB1`:</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;   `python sensniff.py -d /dev/ttyUSB1`</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160; * To run in non-interactive mode:</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;   `python sensniff.py --non-interactive`</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160; * To increase verbosity:</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;   `python sensniff.py -D INFO`</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160; * Use the `-p` argument to save the capture in a pcap file:</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;   `python sensniff.py -p`</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;The host-side script will also print out peripheral debugging output. Any data received not starting with the correct MAGIC (see protocol specification) will be considered to be debugging output from the peripheral and will be printed verbatim, prefixed by &#39;Peripheral: &#39;. Thus, you may see something like this:</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;    Peripheral: sniffer: Command 0x82</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;    Peripheral: sniffer: SET_CHANNEL command</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;    Peripheral: sniffer: Channel 12</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;    Received a command response: [01 0c]</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    Sniffing in channel: 12</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    Peripheral: sniffer: Response [ 53 6e 69 66 01 01 01 0c ]</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;Run Wireshark</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;-------------</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;The host-side tool will convert the frames to PCAP format and pipe them to a FIFO file. All you need to do is to set wireshark to start a capture, using this FIFO file as the capture &#39;interface&#39;. By default, sensniff will use `/tmp/sensniff`.</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;Go to Capture -&gt; options -&gt; Manage Interfaces -&gt; New (under Pipes) -&gt; type `/tmp/sensniff` and save. The pipe will then appear as an interface. Start a capture on it.</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;In older versions of Wireshark, go to Capture -&gt; Options and type `/tmp/sensniff` in the Interface field.</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;You don&#39;t need root priviledges.</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;The first time your run this, you will need to open Wireshark&#39;s preferences and select &#39;TI CC24xx FCS format&#39; under Protocols -&gt; IEEE 802.15.4. You will also need to correctly configure contexts under 6LoWPAN.</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;Project Status</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;==============</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;Protocol Versions</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;-----------------</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;For Host-Peripheral communication, sensniff uses its own minimalistic protocol. The host tool currently suports two version of the protocol:</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160; * **Current version**: This is specified in this README. All future examples and peripheral code will use this version.</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160; * **Legacy version**: This is not documented here and will fade away, eventually. This version only supports frame capturing. Host-initiated commands are not supported.</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;Host-Side Script</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;----------------</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;The host-side script has been tested extensively and should work without major issues. It supports both versions of the sensniff protocol but the legacy version will be removed without any notice.</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;How to Contribute</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;=================</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160; * **Bug reports**: Open a new issue [https://github.com/g-oikonomou/sensniff/issues]</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160; * **Patches**: Please submit them through pull requests [https://github.com/g-oikonomou/sensniff/pulls]</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;sensniff Host-to-Peripheral protocol</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;====================================</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;sensniff uses a minimalistic protocol for the communication between the host and the peripheral. All packets (in both directions) follow this format:</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;                         1                   2                   3</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;    |                             MAGIC                             |</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    |    VERSION    |      CMD      |              LEN              |</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;    |                             DATA                              |</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160; * **MAGIC**: The following 4 bytes (hex): C1 1F FE 72 (&#39;S&#39;+&#39;n&#39; 1F FE &#39;r&#39;)</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160; * **VERSION**: (1 byte). Currently 2.</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160; * **CMD**: (1 byte) Command. See below for possible values.</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160; * **LEN**: (2 bytes) Length of the DATA field in number of bytes. Optional.</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160; Network byte order.</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160; * **DATA**: Variable length specified in LEN. Only transmitted if LEN exists and has value &gt; 0. Contains the payload, depending on the value of CMD.</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;Commands</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;--------</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;Generally speaking, frames with the MS bit of the CMD field set are host-to-peripheral. The MS bit is clear for peripheral-to-host packets.</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;The CMD field can take the following values:</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;   * **CMD==0x00 (CMD_FRAME)**: LEN will contain the length of a captured .15.4 frame. DATA will contain the frame itself, including the .15.4 MAC layer header, payload and FCS. This command is peripheral-initiated.</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;   * **CMD==0x01 (CMD_CHANNEL)**: The current RF channel used by the peripheral&#39;s transceiver. LEN will be 1. DATA will be 1 byte long and will contain the value of the channel. Valid values in [11,26]. Packets of this type are always a response to either CMD_GET_CHANNEL or CMD_SET_CHANNEL.</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;   * **CMD==0x02 (CMD_CHANNEL_MIN)**: The minimum RF channel supported by the peripheral&#39;s transceiver. LEN will be 1. DATA will be 1 byte long and will contain the value of the channel. Packets of this type are a response to CMD_GET_CHANNEL_MIN.</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;   * **CMD==0x03 (CMD_CHANNEL_MAX)**: The maximum RF channel supported by the peripheral&#39;s transceiver. LEN will be 1. DATA will be 1 byte long and will contain the value of the channel. Packets of this type are a response to CMD_GET_CHANNEL_MAX.</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;   * **CMD==0x7F (CMD_ERR_NOT_SUPPORTED)**: The peripheral parsed the command successfully, but it could not execute it. A typical example of when this could happen is when a CMD_SET_CHANNEL requested a channel outside the range supported by the peripheral.</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;   * **CMD==0x81 (CMD_GET_CHANNEL)**: Used by the host to query the current radio channel used by the peripheral&#39;s RF chip. LEN and DATA are omitted. The Peripheral will respond with a CMD_CHANNEL.</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;   * **CMD==0x82 (CMD_GET_CHANNEL_MIN)**: Used by the host to query the minimum radio channel supported by the peripheral&#39;s RF chip. LEN and DATA are omitted. The Peripheral will respond with a CMD_CHANNEL_MIN.</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;   * **CMD==0x83 (CMD_GET_CHANNEL_MAX)**: Used by the host to query the maximum radio channel supported by the peripheral&#39;s RF chip. LEN and DATA are omitted. The Peripheral will respond with a CMD_CHANNEL_MAX.</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;   * **CMD==0x84 (CMD_SET_CHANNEL)**: Used by the host to request a change to a new radio channel. LEN will be 1. DATA will be 1 byte long and will contain the value of the new channel. Valid values depend on the peripheral and can be retrieved through CMD_GET_CHANNEL_MIN &amp; CMD_GET_CHANNEL_MAX. The peripheral will respond with a CMD_CHANNEL.</div></div><!-- fragment --></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jun 10 2017 20:13:49 for Controller by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
